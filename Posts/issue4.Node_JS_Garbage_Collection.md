# Node.js 垃圾回收

## Context

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，因此 Node.js 依赖 V8 进行对象的管理和垃圾回收.

而对于 V8 来说，它的内存大小有限制（32位计算机是 0.7 GB，64位计算机是 1.4GB 左右）—— ***这种限制主要是因为 V8 在大内存的场景下进行 GC 的话，会阻塞 JS 线程几十毫秒到几秒不等的时间***。因此，我们需要一个更加优化且无感知的 GC 过程。

这篇文章会介绍 Node.js 中的垃圾回收算法，讲解 V8 引擎是怎么处理垃圾回收过程的。

## V8 垃圾回收算法

在 V8 中将内存中的对象分成了新生代和老生代对象。

- 新生代：创建时间较短的对象 —— 主要使用 **Scavenge** 算法
- 老生代：存活时间较长或者常驻在内存中的对象 —— 主要使用 **Mark-Sweep 和 Mark-Compact**

***Scavenge 算法***

将堆内存对半分成两个半球 (From 和 To)。写入新数据的时候，往 From 半球写数据。进行 GC 的时候，会检查 From 中的对象，存活的对象才会写入到 To 半球，非存活对象占用的空间直接释放。随后，From 和 To 的身份会反转。

Scavenge 算法牺牲了空间，但是因为它只会复制存活的对象，且对于新生代对象而言，其生命周期较短，因此存活的对象数量不会很多。因此非常适合用于新生代对象。

Scavenge 算法还涉及到 ***对象晋升*** 的逻辑。当我们进行一次复制的时候，如果这个对象已经经历过了一次 Scanvenge 或者 To 空间已经使用了 25% 的空间 —— 那么将这个对象复制到老生代空间，接受新的回收算法处理

***Mark-Sweep 和 Mark-Compact 算法***

对于老生代来说，Scanvenge 不太合适 —— 1）存活对象比较多 2）浪费了一半的空间

Mark-Sweep 是标记清除的意思，分为标记和清除两个阶段。标记阶段遍历内存中的所有对象，并且对于活着的对象进行标记。清除阶段会清除掉所有没有标记的对象（因此可以看出来，Scavenge 只复制活着的对象，Mark-Sweep 只清除死的对象）

但是，Mark-Sweep 会导致内存空间出现不连续的状态，那么如果这个时候来了一个很大的对象，可能每一个碎片空间都没有办法包含这个对象，导致一次不必要的垃圾回收。因此我们会使用 Mark-Compact 来移动内存中的对象，使得它们的内存空间连续 —— 然而，由于涉及到移动对象，Mark-Compact 会很慢，因此一般只有在内存不足以容纳从新生代新晋升的对象的时候，才会使用 Mark-Compact

## 其他优化

***Incremental Marking***

为了避免状态一致性问题（例如JS应用看到的状态和垃圾回收器看到的状态不一样），每次执行 GC 的时候会有一次 ***全停顿 stop the world***，彻底停止 JS 线程。新生代的 GC 效率很高，因此全停顿问题也不大。但是相应的，老生代的 GC 耗时较长，全停顿会导致严重的性能降级。

其中一个优化方案是增量标记 incremental marking，这个改进是将原本需要一口气完成的 Mark 阶段，断断续续的分成多段，每一段之间穿插 JS 线程的执行。等到需要 Sweep 的时候，大部分的内存都已经扫描过了，就不需要从头开始扫描

***Accurate GC***

V8 的 GC 被称为 accurate GC：

- node中，对象类型会按照4/8字对齐，因此末位必定为00/000，因此 Node.js 保留末尾来表示数据类型，当末尾为 0 的时候即为 int。当GC的时候，可以通过这个直接跳过所有的整数，只针对对象进行GC。
- 好处在于V8可以知道这个东西到底是一个整数还是一个指向对象的指针。如果没有这个机制，那么V8只能假设所有的都是指向对象的指针然后再去check。显然效率更低。

```js
// Formats of Object::ptr_:
//  Smi:        [31 bit signed int] 0
//  HeapObject: [32 bit direct pointer] (4 byte aligned) | 01
```

reference: https://www.zhihu.com/question/62732293
